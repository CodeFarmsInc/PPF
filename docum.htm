<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns:m="http://schemas.microsoft.com/office/2004/12/omml"
xmlns:st1="urn:schemas-microsoft-com:office:smarttags"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 14">
<meta name=Originator content="Microsoft Word 14">
<link rel=File-List href="docum_files/filelist.xml">
<link rel=Edit-Time-Data href="docum_files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]--><o:SmartTagType
 namespaceuri="urn:schemas-microsoft-com:office:smarttags" name="State"/>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="place"/>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author> </o:Author>
  <o:Template>Normal</o:Template>
  <o:LastAuthor>Jiri</o:LastAuthor>
  <o:Revision>6</o:Revision>
  <o:TotalTime>33</o:TotalTime>
  <o:Created>2003-01-30T01:15:00Z</o:Created>
  <o:LastSaved>2012-10-07T05:27:00Z</o:LastSaved>
  <o:Pages>8</o:Pages>
  <o:Words>4305</o:Words>
  <o:Characters>24544</o:Characters>
  <o:Company> </o:Company>
  <o:Lines>204</o:Lines>
  <o:Paragraphs>57</o:Paragraphs>
  <o:CharactersWithSpaces>28792</o:CharactersWithSpaces>
  <o:Version>14.00</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<link rel=themeData href="docum_files/themedata.thmx">
<link rel=colorSchemeMapping href="docum_files/colorschememapping.xml">
<!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:TrackMoves>false</w:TrackMoves>
  <w:TrackFormatting/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:DoNotPromoteQF/>
  <w:LidThemeOther>EN-CA</w:LidThemeOther>
  <w:LidThemeAsian>X-NONE</w:LidThemeAsian>
  <w:LidThemeComplexScript>X-NONE</w:LidThemeComplexScript>
  <w:Compatibility>
   <w:BreakWrappedTables/>
   <w:SplitPgBreakAndParaMark/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
  <m:mathPr>
   <m:mathFont m:val="Cambria Math"/>
   <m:brkBin m:val="before"/>
   <m:brkBinSub m:val="&#45;-"/>
   <m:smallFrac m:val="off"/>
   <m:dispDef/>
   <m:lMargin m:val="0"/>
   <m:rMargin m:val="0"/>
   <m:defJc m:val="centerGroup"/>
   <m:wrapIndent m:val="1440"/>
   <m:intLim m:val="subSup"/>
   <m:naryLim m:val="undOvr"/>
  </m:mathPr></w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" DefUnhideWhenUsed="false"
  DefSemiHidden="false" DefQFormat="false" LatentStyleCount="267">
  <w:LsdException Locked="false" QFormat="true" Name="Normal"/>
  <w:LsdException Locked="false" QFormat="true" Name="heading 1"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 2"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 3"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 4"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 5"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 6"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 7"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 8"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="heading 9"/>
  <w:LsdException Locked="false" SemiHidden="true" UnhideWhenUsed="true"
   QFormat="true" Name="caption"/>
  <w:LsdException Locked="false" QFormat="true" Name="Title"/>
  <w:LsdException Locked="false" Priority="1" Name="Default Paragraph Font"/>
  <w:LsdException Locked="false" QFormat="true" Name="Subtitle"/>
  <w:LsdException Locked="false" QFormat="true" Name="Strong"/>
  <w:LsdException Locked="false" QFormat="true" Name="Emphasis"/>
  <w:LsdException Locked="false" Priority="99" Name="No List"/>
  <w:LsdException Locked="false" Priority="99" SemiHidden="true"
   Name="Placeholder Text"/>
  <w:LsdException Locked="false" Priority="1" QFormat="true" Name="No Spacing"/>
  <w:LsdException Locked="false" Priority="60" Name="Light Shading"/>
  <w:LsdException Locked="false" Priority="61" Name="Light List"/>
  <w:LsdException Locked="false" Priority="62" Name="Light Grid"/>
  <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1"/>
  <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2"/>
  <w:LsdException Locked="false" Priority="65" Name="Medium List 1"/>
  <w:LsdException Locked="false" Priority="66" Name="Medium List 2"/>
  <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1"/>
  <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2"/>
  <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3"/>
  <w:LsdException Locked="false" Priority="70" Name="Dark List"/>
  <w:LsdException Locked="false" Priority="71" Name="Colorful Shading"/>
  <w:LsdException Locked="false" Priority="72" Name="Colorful List"/>
  <w:LsdException Locked="false" Priority="73" Name="Colorful Grid"/>
  <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 1"/>
  <w:LsdException Locked="false" Priority="61" Name="Light List Accent 1"/>
  <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 1"/>
  <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 1"/>
  <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 1"/>
  <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 1"/>
  <w:LsdException Locked="false" Priority="99" SemiHidden="true" Name="Revision"/>
  <w:LsdException Locked="false" Priority="34" QFormat="true"
   Name="List Paragraph"/>
  <w:LsdException Locked="false" Priority="29" QFormat="true" Name="Quote"/>
  <w:LsdException Locked="false" Priority="30" QFormat="true"
   Name="Intense Quote"/>
  <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 1"/>
  <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 1"/>
  <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 1"/>
  <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 1"/>
  <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 1"/>
  <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 1"/>
  <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 1"/>
  <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 1"/>
  <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 2"/>
  <w:LsdException Locked="false" Priority="61" Name="Light List Accent 2"/>
  <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 2"/>
  <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 2"/>
  <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 2"/>
  <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 2"/>
  <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 2"/>
  <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 2"/>
  <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 2"/>
  <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 2"/>
  <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 2"/>
  <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 2"/>
  <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 2"/>
  <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 2"/>
  <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 3"/>
  <w:LsdException Locked="false" Priority="61" Name="Light List Accent 3"/>
  <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 3"/>
  <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 3"/>
  <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 3"/>
  <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 3"/>
  <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 3"/>
  <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 3"/>
  <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 3"/>
  <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 3"/>
  <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 3"/>
  <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 3"/>
  <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 3"/>
  <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 3"/>
  <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 4"/>
  <w:LsdException Locked="false" Priority="61" Name="Light List Accent 4"/>
  <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 4"/>
  <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 4"/>
  <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 4"/>
  <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 4"/>
  <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 4"/>
  <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 4"/>
  <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 4"/>
  <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 4"/>
  <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 4"/>
  <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 4"/>
  <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 4"/>
  <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 4"/>
  <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 5"/>
  <w:LsdException Locked="false" Priority="61" Name="Light List Accent 5"/>
  <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 5"/>
  <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 5"/>
  <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 5"/>
  <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 5"/>
  <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 5"/>
  <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 5"/>
  <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 5"/>
  <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 5"/>
  <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 5"/>
  <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 5"/>
  <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 5"/>
  <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 5"/>
  <w:LsdException Locked="false" Priority="60" Name="Light Shading Accent 6"/>
  <w:LsdException Locked="false" Priority="61" Name="Light List Accent 6"/>
  <w:LsdException Locked="false" Priority="62" Name="Light Grid Accent 6"/>
  <w:LsdException Locked="false" Priority="63" Name="Medium Shading 1 Accent 6"/>
  <w:LsdException Locked="false" Priority="64" Name="Medium Shading 2 Accent 6"/>
  <w:LsdException Locked="false" Priority="65" Name="Medium List 1 Accent 6"/>
  <w:LsdException Locked="false" Priority="66" Name="Medium List 2 Accent 6"/>
  <w:LsdException Locked="false" Priority="67" Name="Medium Grid 1 Accent 6"/>
  <w:LsdException Locked="false" Priority="68" Name="Medium Grid 2 Accent 6"/>
  <w:LsdException Locked="false" Priority="69" Name="Medium Grid 3 Accent 6"/>
  <w:LsdException Locked="false" Priority="70" Name="Dark List Accent 6"/>
  <w:LsdException Locked="false" Priority="71" Name="Colorful Shading Accent 6"/>
  <w:LsdException Locked="false" Priority="72" Name="Colorful List Accent 6"/>
  <w:LsdException Locked="false" Priority="73" Name="Colorful Grid Accent 6"/>
  <w:LsdException Locked="false" Priority="19" QFormat="true"
   Name="Subtle Emphasis"/>
  <w:LsdException Locked="false" Priority="21" QFormat="true"
   Name="Intense Emphasis"/>
  <w:LsdException Locked="false" Priority="31" QFormat="true"
   Name="Subtle Reference"/>
  <w:LsdException Locked="false" Priority="32" QFormat="true"
   Name="Intense Reference"/>
  <w:LsdException Locked="false" Priority="33" QFormat="true" Name="Book Title"/>
  <w:LsdException Locked="false" Priority="37" SemiHidden="true"
   UnhideWhenUsed="true" Name="Bibliography"/>
  <w:LsdException Locked="false" Priority="39" SemiHidden="true"
   UnhideWhenUsed="true" QFormat="true" Name="TOC Heading"/>
 </w:LatentStyles>
</xml><![endif]--><!--[if !mso]><object
 classid="clsid:38481807-CA0E-42D2-BF39-B33AF135CC4D" id=ieooui></object>
<style>
st1\:*{behavior:url(#ieooui) }
</style>
<![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:-520081665 -1073717157 41 0 66047 0;}
@font-face
	{font-family:Consolas;
	panose-1:2 11 6 9 2 2 4 3 2 4;
	mso-font-charset:0;
	mso-generic-font-family:modern;
	mso-font-pitch:fixed;
	mso-font-signature:-520092929 1073806591 9 0 415 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-unhide:no;
	mso-style-qformat:yes;
	mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";
	mso-fareast-font-family:"Times New Roman";}
p
	{mso-style-unhide:no;
	mso-margin-top-alt:auto;
	margin-right:0cm;
	mso-margin-bottom-alt:auto;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman","serif";
	mso-fareast-font-family:"Times New Roman";}
pre
	{mso-style-unhide:no;
	mso-style-link:"HTML Preformatted Char";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
p.MsoAcetate, li.MsoAcetate, div.MsoAcetate
	{mso-style-unhide:no;
	mso-style-link:"Balloon Text Char";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:8.0pt;
	font-family:"Tahoma","sans-serif";
	mso-fareast-font-family:"Times New Roman";}
span.HTMLPreformattedChar
	{mso-style-name:"HTML Preformatted Char";
	mso-style-unhide:no;
	mso-style-locked:yes;
	mso-style-link:"HTML Preformatted";
	font-family:Consolas;
	mso-ascii-font-family:Consolas;
	mso-hansi-font-family:Consolas;
	mso-bidi-font-family:Consolas;}
span.BalloonTextChar
	{mso-style-name:"Balloon Text Char";
	mso-style-unhide:no;
	mso-style-locked:yes;
	mso-style-link:"Balloon Text";
	mso-ansi-font-size:8.0pt;
	mso-bidi-font-size:8.0pt;
	font-family:"Tahoma","sans-serif";
	mso-ascii-font-family:Tahoma;
	mso-hansi-font-family:Tahoma;
	mso-bidi-font-family:Tahoma;}
.MsoChpDefault
	{mso-style-type:export-only;
	mso-default-props:yes;
	font-size:10.0pt;
	mso-ansi-font-size:10.0pt;
	mso-bidi-font-size:10.0pt;}
@page WordSection1
	{size:612.0pt 792.0pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	mso-header-margin:35.4pt;
	mso-footer-margin:35.4pt;
	mso-paper-source:0;}
div.WordSection1
	{page:WordSection1;}
 /* List Definitions */
 @list l0
	{mso-list-id:1315792319;
	mso-list-template-ids:1219557832;}
@list l1
	{mso-list-id:1426220099;
	mso-list-template-ids:1837038984;}
@list l1:level1
	{mso-level-tab-stop:36.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level2
	{mso-level-tab-stop:72.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level3
	{mso-level-tab-stop:108.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level4
	{mso-level-tab-stop:144.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level5
	{mso-level-tab-stop:180.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level6
	{mso-level-tab-stop:216.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level7
	{mso-level-tab-stop:252.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level8
	{mso-level-tab-stop:288.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
@list l1:level9
	{mso-level-tab-stop:324.0pt;
	mso-level-number-position:left;
	text-indent:-18.0pt;}
ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-priority:99;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman","serif";}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="1026"/>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body bgcolor=white lang=EN-CA style='tab-interval:36.0pt'>

<div class=WordSection1>

<div align=center>

<table class=MsoNormalTable border=0 cellpadding=0 width=780 style='width:585.0pt;
 mso-cellspacing:1.5pt;mso-yfti-tbllook:1184;mso-padding-alt:0cm 5.4pt 0cm 5.4pt'>
 <tr style='mso-yfti-irow:0;mso-yfti-firstrow:yes;mso-yfti-lastrow:yes'>
  <td style='padding:.75pt .75pt .75pt .75pt'>
  <p class=MsoNormal><span style='mso-no-proof:yes'><img width=90 height=90
  id="_x0000_i1025" src="../../images/ppf.gif" alt="Description: PPF"></span><b>Copyright
  (C) Code Farms Inc. 1998 - 2001</b></p>
  <p><b><span style='font-size:18.0pt'>Persistent Pointer Factory</span></b></p>
  <p class=MsoNormal><b>(documentation Ver.1.4 - December 2000)</b></p>
  <p><b>BASIC IDEA</b></p>
  <p>PPF helps you to build custom databases, which are fast and can handle
  large volume of data efficiently even on an ordinary PC. PPF is small (30kB
  object file), and the resulting databases are often by an order of magnitude
  faster than ready-made commercial databases. </p>
  <p>PPF gives you three smart pointer classes:</p>
  <p>PersistString - equivalent of char* for variable length text strings;</p>
  <p>PersistPtr&lt;T&gt; - equivalent of T* for lightweight class T which does
  not use inheritance;</p>
  <p>PersistVptr&lt;T&gt; - equivalent of T* for class T which uses inheritance
  and virtual functions.</p>
  <p>If you replace all pointers in your program by these smart pointers, all
  objects in your program become automatically persistent (stored on disk).</p>
  <p>Note the conceptual difference of this approach from the persistent
  objects based on serialization. Such objects reside in memory, and you store
  this memory image - usually at the end of the run. The objects must be loaded
  back to memory when you want to use them again. This is a slow process, and
  does not permit you to handle large data sets efficiently.</p>
  <p>PPF takes a different approach. It keeps the data on disk, and pages it to
  memory only when needed. You can retrieve individual objects or small
  subsets, have fast access to the data, and since you have full control over
  the paging, you can tune up the performance of your database. Objects of some
  classes may always be in memory, while other class may never have more than
  one object in memory. The size of your disk space is the only limit on how
  much data you can store. PPF also provides a transparent management and reuse
  of the data space, including free lists. </p>
  <p>Other advantages of PPF:</p>
  <p class=MsoNormal><span style='mso-hansi-font-family:Symbol'>7</span> No
  need to code serialization functions, which is a tedious and error-prone
  task. A </p>
  <p class=MsoNormal><span style='mso-hansi-font-family:Symbol'>7</span> Your
  data set may far exceed both the RAM and the virtual memory space. </p>
  <p class=MsoNormal><span style='mso-hansi-font-family:Symbol'>7</span> Free
  lists by-pass expensive allocation and initialization of C++ objects. </p>
  <p class=MsoNormal><span style='mso-hansi-font-family:Symbol'>7</span> When
  you stop your program, most of your data is already on disk; only a few pages
  have to move from memory to disk, which is very fast. This also helps in
  crash recovery. </p>
  <p class=MsoNormal><span style='mso-hansi-font-family:Symbol'>7</span> The
  smart pointers are space efficient. The storage on disk typically takes less
  space than your objects in memory. The size of PersistPtr is the same as
  sizeof(char*), PersistVptr takes twice as much. </p>
  <p><b>FIRST EXAMPLE</b></p>
  <p>The use of PPF is so simple that, except for this short instruction, no
  documentation is required. Just to give you the first feeling how PPF works,
  consider the following example:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>class B {</pre><pre><span style='mso-spacerun:yes'>        </span>int b;</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre><pre><span style='mso-spacerun:yes'>    </span>class A {</pre><pre><span style='mso-spacerun:yes'>        </span>int a;</pre><pre><span style='mso-spacerun:yes'>        </span>A *aPtr;</pre><pre><span style='mso-spacerun:yes'>        </span>B *bPtr;</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>If
  you tag your classes with the PersistClass(..) statement, and replace all
  pointers by the smart pointer PersistPtr&lt;...&gt;, your classes will become
  automatically persistent:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>class B {</pre><pre><span style='mso-spacerun:yes'>        </span>PersistClass(B);</pre><pre><span style='mso-spacerun:yes'>        </span>int b;</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre><pre><span style='mso-spacerun:yes'>    </span>class A {</pre><pre><span style='mso-spacerun:yes'>        </span>PersistClass(A);</pre><pre><span style='mso-spacerun:yes'>        </span>int i;</pre><pre><span style='mso-spacerun:yes'>   </span><span style='mso-spacerun:yes'>     </span>PersistPtr&lt;A&gt; aPtr;</pre><pre><span style='mso-spacerun:yes'>        </span>PersistPtr&lt;B&gt; bPtr;</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>There
  are several minor things we still have to add - they will be explained
  shortly.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>LIMITATION</b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>(A)
  When calling a function, you can pass PersistPtr&lt;&gt; either as a copy, or
  as a reference:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>  </span>void foo1(PersistPtr&lt;A&gt; a){ // copy of 'a' is used inside foo1()</pre><pre><span style='mso-spacerun:yes'>      </span>if(a-&gt;i)...</pre><pre><span style='mso-spacerun:yes'>  </span>}</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>  </span>void foo2(PersistPtr&lt;A&gt;&amp; a){ // address of 'a' is used inside foo2()</pre><pre><span style='mso-spacerun:yes'>      </span>a-&gt;i = 0;</pre><pre><span style='mso-spacerun:yes'>  </span>}</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>(B)
  Function calls are restricted by the following rules:</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>(1)
  When passing a persistent object to a function, pass the PersistPtr&lt;&gt;,
  not the object.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>(2)
  The function parameters must not be expressions using operators -&gt; . &amp;
  or * on persistent objects.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Examples:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>  </span>class A {</pre><pre><span style='mso-spacerun:yes'>      </span>PersistClass(A);</pre><pre><span style='mso-spacerun:yes'>      </span>PersistPtr&lt;A&gt; next;</pre><pre><span style='mso-spacerun:yes'>      </span>int id;</pre><pre><span style='mso-spacerun:yes'>      </span>...</pre><pre><span style='mso-spacerun:yes'>  </span>};</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>  </span>void foo3(A a){ // NOT allowed, violation of rule (1)</pre><pre><span style='mso-spacerun:yes'>      </span>a.i = 0;</pre><pre><span style='mso-spacerun:yes'>      </span>...</pre><pre><span style='mso-spacerun:yes'>  </span>}</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>  </span>void foo4(int *i){ // OK, appears not to deal with persistent objects</pre><pre><span style='mso-spacerun:yes'>      </span>*i = 0;</pre><pre><span style='mso-spacerun:yes'>      </span>...</pre><pre><span style='mso-spacerun:yes'>  </span>}</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>  </span>int k;</pre><pre><span style='mso-spacerun:yes'>  </span>PersistPtr&lt;A&gt; ap,tmpPtr;</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>  </span>ap = new A;</pre><pre><span style='mso-spacerun:yes'>  </span>foo1(ap); // OK</pre><pre><span style='mso-spacerun:yes'>  </span>foo2(ap); // OK</pre><pre><span style='mso-spacerun:yes'>  </span>foo2(ap-&gt;next); // violation of rule (2), may crash</pre><pre><span style='mso-spacerun:yes'>  </span>foo4(&amp;(ap-&gt;id)); // violation of rule (2), may update id in a wrong object</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Correct
  uses:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>  </span>tmpPtr = ap-&gt;next;</pre><pre><span style='mso-spacerun:yes'>  </span>foo2(tmpPtr);</pre><pre><span style='mso-spacerun:yes'>  </span>ap-&gt;next = tmpPtr;</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>  </span>k = a-&gt;i;</pre><pre><span style='mso-spacerun:yes'>  </span>foo3(&amp;k);</pre><pre><span style='mso-spacerun:yes'>  </span>a-&gt;i = k;</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>(C)
  Reference to 'this' must be avoided because 'this' is a raw pointer and not a
  persistent pointer. Conversion from raw to persistent pointer is generally
  unsafe because the disk content is continuously paged in and out. The use of
  'this' can easily be avoided by coding in one of the following two styles: </p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>// --------------------------------------------</pre><pre><span style='mso-spacerun:yes'>    </span>// Original (non-persistent) code using 'this'</pre><pre><span style='mso-spacerun:yes'>    </span>class A {</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>        </span>A *foo(int i){</pre><pre><span style='mso-spacerun:yes'>           </span>if(i&gt;0)return flip();</pre><pre><span style='mso-spacerun:yes'>           </span>else return this;</pre><pre><span style='mso-spacerun:yes'>        </span>}</pre><pre><span style='mso-spacerun:yes'>        </span>A *flip();</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>// Application</pre><pre><span style='mso-spacerun:yes'>    </span>A *a; int i;</pre><pre><span style='mso-spacerun:yes'>    </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>a=new A;</pre><pre><span style='mso-spacerun:yes'>    </span>a-&amp;gtfoo(i);</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>// --------------------------------------------</pre><pre><span style='mso-spacerun:yes'>    </span>// Persistent code avoiding 'this', style 1</pre><pre><span style='mso-spacerun:yes'>    </span>class A {</pre><pre><span style='mso-spacerun:yes'>    </span>PersistClass(A);</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>        </span>PersistPtr&amp;ltA&gt; foo(PersistPtr&amp;ltA&gt; me, int i){</pre><pre><span style='mso-spacerun:yes'>           </span>if(i&gt;0)return flip();</pre><pre><span style='mso-spacerun:yes'>           </span>else return me;</pre><pre><span style='mso-spacerun:yes'>        </span>}</pre><pre><span style='mso-spacerun:yes'>        </span>PersistPtr&amp;ltA&gt; flip();</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>// Application</pre><pre><span style='mso-spacerun:yes'>    </span>PersistPtr&amp;ltA&gt; a; int i;</pre><pre><span style='mso-spacerun:yes'>    </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>a=new A;</pre><pre><span style='mso-spacerun:yes'>    </span>a-&amp;gtfoo(a,i);</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>// --------------------------------------------</pre><pre><span style='mso-spacerun:yes'>    </span>// Persistent code avoiding 'this', style 2</pre><pre><span style='mso-spacerun:yes'>    </span>class A {</pre><pre><span style='mso-spacerun:yes'>    </span>PersistClass(A);</pre><pre><span style='mso-spacerun:yes'>    </span>PersistPtr&amp;ltA&gt; me; // additional member</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>        </span>PersistPtr&amp;ltA&gt; foo(int i){</pre><pre><span style='mso-spacerun:yes'>           </span>if(i&gt;0)return flip();</pre><pre><span style='mso-spacerun:yes'>           </span>else return me;</pre><pre><span style='mso-spacerun:yes'>        </span>}</pre><pre><span style='mso-spacerun:yes'>        </span>PersistPtr&amp;ltA&gt; flip();</pre><pre><span style='mso-spacerun:yes'>        </span>static PersistPtr&amp;ltA&gt; newObj(){</pre><pre><span style='mso-spacerun:yes'>            </span>PersistPtr&amp;ltA&gt; p; p=new A; p-&gt;gtme=p; return p;</pre><pre><span style='mso-spacerun:yes'>        </span>}</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>// Application</pre><pre><span style='mso-spacerun:yes'>    </span>PersistPtr&amp;ltA&gt; a; int i;</pre><pre><span style='mso-spacerun:yes'>    </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>a=A::newObj();</pre><pre><span style='mso-spacerun:yes'>    </span>a-&amp;gtfoo(i);</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span></pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>LIGHT-WEIGHT
  CLASSES AND HEAVY-WEIGHT CLASSES</b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The
  previous example assumed that classes A and B are &quot;light-weight&quot;, which
  means that they do not use inheritance. Smart pointers which point to normal
  (or &quot;heavy-weight&quot;) objects must be smarter. They keep 8 bytes of
  information compared to 4 bytes required by smart pointers for light-weight
  objects. In many applications, most of the classes fall into the light-weight
  category, and using the 8-byte pointers is a waste of space. For this reason,
  PPF provides two sets of classes and pointers:</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>PersistClass(T),
  PersistPtr&lt;T&gt; ... for light-weight class T;</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>PersistVclass(T),
  PersistVptr&lt;T&gt; ... for heavy-weight class T.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>If
  you don't want to bother with the two different kinds of classes, use the
  heavy-weight option all the time.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Let's
  expand the example above by deriving class B from class C. Class A is still
  leight-weight:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>class C {</pre><pre><span style='mso-spacerun:yes'>        </span>PersistVclass(C);</pre><pre><span style='mso-spacerun:yes'>        </span>int c;</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre><pre><span style='mso-spacerun:yes'>    </span>class B : public C {</pre><pre><span style='mso-spacerun:yes'>        </span>PersistVclass(B);</pre><pre><span style='mso-spacerun:yes'>        </span>int b;</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre><pre><span style='mso-spacerun:yes'>    </span>class A {</pre><pre><span style='mso-spacerun:yes'>        </span>PersistClass(A);</pre><pre><span style='mso-spacerun:yes'>        </span>int i;</pre><pre><span style='mso-spacerun:yes'>        </span>PersistPtr&lt;A&gt; aPtr;</pre><pre><span style='mso-spacerun:yes'>        </span>PersistVptr&lt;C&gt; bPtr;</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>FILE
  ORGANIZATION</b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The
  entire PPF is very small (object file about 30kB), and comes in only 3 files:</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>(1)
  factory.h - provides templates for the PersistPtr&lt;&gt;,
  PersistVptr&lt;&gt;, and definitions of PersistString and PersistFactory.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>(2)
  pointer.cpp (pointer.cc) - implementation of PersistPtr&lt;&gt; and
  PersistVptr&lt;&gt;</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>(3)
  factory.obj (factory.o) - all the remaining functions.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>If
  you keep keep the usual file organization (files x.h and x.cpp for class X),
  you have to use the following includes:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre>FILE x.h:</pre><pre><span style='mso-spacerun:yes'>    </span>#include &quot;factory.h&quot;</pre><pre><span style='mso-spacerun:yes'>    </span>class X {</pre><pre><span style='mso-spacerun:yes'>        </span>PersistClass(X); // of PersistVclass(X)</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre><pre><span style='mso-spacerun:yes'>    </span>#include &quot;pointer.cpp&quot; // always include when smart pointers are used</pre><pre><o:p>&nbsp;</o:p></pre><pre>FILE x.cpp:</pre><pre><span style='mso-spacerun:yes'>    </span>#include &quot;x.h&quot;</pre><pre><span style='mso-spacerun:yes'>    </span>PersistImplement(X);<span style='mso-spacerun:yes'>  </span>// same for leight-weight and heavy-weight</pre><pre><span style='mso-spacerun:yes'>    </span>... implementation of X methods....</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>PersistImplement(X)
  hides the implementation of the methods that have been added to class X under
  PersistClass(X), and which are necessary for the management of the
  persistency. This is a simple macro - only 2 lines of code, and comes file
  factory.h. When linking your program, you have to link to factory.obj.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>PLATFORM
  AND COMPILER</b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>If
  you received a binary version of PPF, it is already customized to the platform
  and compiler you ordered. </p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>If
  you received the full source of PPF (multi-platform), the source is set for
  DOS or Windows (Win95, Win98, WinNT) and the Microsoft VC++ compiler. If you
  run in a different environment, edit file factory.h, search for the text
  string &quot;DOS&quot;, and comment or un-comment #define statements
  depending on your environment.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>PERSISTENT
  POINTERS</b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>PPF
  pointers have most of the functionality you would expect from a normal
  pointer. The following list of functions applies to both PersistPtr&lt;T&gt;
  and to PersistVptr&lt;T&gt;:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>PersistPtr();<span style='mso-spacerun:yes'>           </span>// constructor which initializes the pointer</pre><pre><span style='mso-spacerun:yes'>                            </span>// to what is NULL for the regular pointer</pre><pre><span style='mso-spacerun:yes'>    </span>PersistPtr(T* realPtr); // initialized by a normal pointer</pre><pre><span style='mso-spacerun:yes'>    </span>PersistPtr(const PersistPtr&amp; rhs); // initialized by a smart pointer</pre><pre><span style='mso-spacerun:yes'>    </span>~PersistPtr();<span style='mso-spacerun:yes'>          </span>// delete the pointer without deleting the object</pre><pre><span style='mso-spacerun:yes'>                            </span>// to which it points</pre><pre><span style='mso-spacerun:yes'>    </span>PersistPtr&amp; operator=(const PersistPtr&amp; rhs); // normal assignment</pre><pre><span style='mso-spacerun:yes'>    </span>PersistPtr&amp; operator=(long rhs); // interpreting properly a long index</pre><pre><span style='mso-spacerun:yes'>    </span>int operator==(const PersistPtr&amp; rhs); // pointers are equal if the point</pre><pre><span style='mso-spacerun:yes'>                             </span>// to the same object</pre><pre><span style='mso-spacerun:yes'>    </span>int operator!=(const PersistPtr&amp; rhs); // same for not-equal</pre><pre><span style='mso-spacerun:yes'>    </span>T* operator-&gt;() const;<span style='mso-spacerun:yes'>   </span>// operator -&gt; works as usual</pre><pre><span style='mso-spacerun:yes'>    </span>T&amp; operator*() const;<span style='mso-spacerun:yes'>    </span>// operator * returns the object to which the </pre><pre><span style='mso-spacerun:yes'>                             </span>// pointer points</pre><pre><span style='mso-spacerun:yes'>    </span>T&amp; operator[](long incr);// indexing into an array works as usual</pre><pre><span style='mso-spacerun:yes'>    </span>long getIndex();<span style='mso-spacerun:yes'>         </span>// the index is really the disk address</pre><pre><span style='mso-spacerun:yes'>    </span>void setNull();<span style='mso-spacerun:yes'>          </span>// sets the pointer to the equivalent of NULL</pre><pre><span style='mso-spacerun:yes'>    </span>PersistPtr&lt;T&gt;&amp; newArr(long size);<span style='mso-spacerun:yes'>    </span>// equivalent of<span style='mso-spacerun:yes'>    </span>T::new T[]()</pre><pre><span style='mso-spacerun:yes'>    </span>void delObj();<span style='mso-spacerun:yes'>          </span><span style='mso-spacerun:yes'>             </span>// equivalent of T::delete()</pre><pre><span style='mso-spacerun:yes'>    </span>void delArr();<span style='mso-spacerun:yes'>                       </span>// equivalent of T::delete[]()</pre><pre><span style='mso-spacerun:yes'>    </span>void getRoot();<span style='mso-spacerun:yes'>          </span>// gets the root object of this class</pre><pre><span style='mso-spacerun:yes'>    </span>void setRoot();<span style='mso-spacerun:yes'>          </span>// sets the object to be the root of this class.</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>For
  each class, you can assign one object as its 'root', and retrieve this root
  on the subsequent runs. This provides a convenient hook or hooks for your
  data structures:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>        </span>px.setRoot();<span style='mso-spacerun:yes'>   </span>// assigns px to be the root of its class</pre><pre><span style='mso-spacerun:yes'>        </span>px.getRoot();<span style='mso-spacerun:yes'>   </span>// sets px to the root of its class</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>THE
  STRING CLASS</b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Class
  PersistString is not a template, and it manages variable-length strings on
  disk. All strings are stored on the same disk (file string.ppf).</p>
  <pre><o:p>&nbsp;</o:p></pre><pre>class PersistString {</pre><pre>public:<span style='mso-spacerun:yes'>                                                                      </span></pre><pre><span style='mso-spacerun:yes'>    </span>// allocation</pre><pre><span style='mso-spacerun:yes'>    </span>PersistString(); // equivalent of NULL pointer</pre><pre><span style='mso-spacerun:yes'>    </span>PersistString(long sz); // assigns string of length sz</pre><pre><span style='mso-spacerun:yes'>    </span>PersistString(char *s); // creates space and copies NULL ending s into it</pre><pre><span style='mso-spacerun:yes'>    </span>~PersistString(); // destroys the pointer, not the string</pre><pre><span style='mso-spacerun:yes'>    </span>void delString(); // deletes the string, sets the pointer to NULL</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>// pager is controlled differently for each class</pre><pre><span style='mso-spacerun:yes'>    </span>static void startPager(long pgSz,long maxPgs,long totMem,int rd); </pre><pre><span style='mso-spacerun:yes'>    </span>static void closePager();</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>// operators</pre><pre><span style='mso-spacerun:yes'>    </span>PersistString&amp; operator=(const PersistString&amp; rhs);</pre><pre><span style='mso-spacerun:yes'>    </span>PersistString&amp; operator=(long rhs);</pre><pre><span style='mso-spacerun:yes'>    </span>PersistString&amp; operator=(PersistString* realPtr);</pre><pre><span style='mso-spacerun:yes'>    </span>int operator==(const PersistString&amp; rhs);</pre><pre><span style='mso-spacerun:yes'>    </span>int operator!=(const PersistString&amp; rhs);</pre><pre><span style='mso-spacerun:yes'>    </span>char* operator-&gt;();</pre><pre><span style='mso-spacerun:yes'>    </span>char operator[](long incr);</pre><pre><span style='mso-spacerun:yes'>    </span>void setNull();</pre><pre><span style='mso-spacerun:yes'>    </span>char *getPtr(long <st1:State
  w:st="on"><st1:place w:st="on">ind</st1:place></st1:State>); // moves string from a given address to memory</pre><pre><span style='mso-spacerun:yes'>    </span>char *getPtr(); <span style='mso-spacerun:yes'>      </span>// moves this string to memory and returns pointer</pre><pre><span style='mso-spacerun:yes'>    </span>long getInd(char *s); // special use: get disk address for a memory pointer</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>// manipulating strings (this group will be significantly expanded)</pre><pre><span style='mso-spacerun:yes'>    </span>int cmp(const PersistString&amp; s); // compare two strings</pre><pre><span style='mso-spacerun:yes'>    </span>size_t size();<span style='mso-spacerun:yes'>                   </span>// get the size of the string</pre><pre><span style='mso-spacerun:yes'>    </span>long allocSize();<span style='mso-spacerun:yes'>  </span>// get the allocated size, which may be bigger </pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>METHODS
  ADDED TO YOUR CLASS</b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Macros
  PersistClass(T) and PersistVclass(T) add the following methods to your
  classes:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>void* operator new(size_t size); // overloads operator new, so you can</pre><pre><span style='mso-spacerun:yes'>                                     </span>// allocate new objects as usual</pre><pre><span style='mso-spacerun:yes'>   
 </span>static void startPager(long pgSz,long maxPgs,long totMem, int rd);</pre><pre><span style='mso-spacerun:yes'>          </span>// starts the pager for class T with the following parameters:</pre><pre><span style='mso-spacerun:yes'>          </span>// pgSz=page size,,</pre><pre><span style='mso-spacerun:yes'>          // maxPgs=max.number of pages in memory at any time,</pre><pre><span style='mso-spacerun:yes'>          </span>// totMem=estimate of the total space for the objects of this class</pre><pre><span style='mso-spacerun:yes'>          </span>// rd=1 for read-only access, rd=0 for read/write,</pre><pre><span style='mso-spacerun:yes'>          </span>// rd=2 for red/write using shadow pages (more memory used but a more efficient IO) </pre><pre><span style='mso-spacerun:yes'>
 </span>static void startPagerObj(long numObjPg,long objInMem,long maxObj, int rd);</pre><pre><span style='mso-spacerun:yes'>          </span>// starts the pager for class T with the following parameters:</pre><pre><span style='mso-spacerun:yes'>          </span>// numObjPg=number of objects per page,</pre><pre><span style='mso-spacerun:yes'>          </span>// objInMem=max.number of objects in memory at any time,</pre><pre><span style='mso-spacerun:yes'>          </span>// maxObj=save upper limit on the number of objects of this class; making it higher does not cause much overhead; select 0 for unlimited</pre><pre><span style='mso-spacerun:yes'>          </span>// rd=1 for read-only access, rd=0 for read/write,</pre><pre><span style='mso-spacerun:yes'>          </span>// rd=2 for red/write using shadow pages (more memory used but a more efficient IO) </pre><pre><span style='mso-spacerun:yes'>
    </span>static void closePager(); // close the pager and move all data to disk.</pre><pre><span style='mso-spacerun:yes'>    </span>T(); // default constructor - provided only for PersistVclass-es.</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>
Note that startPager() and startPagerObj() have the same functionality. Decide yourself whether you want to control the paging in bytes of by the number of objects. Note that unless an adjustment is really necessary, startPager() uses exactly the parameters you specify. However, startPagerObj() optimizes the given parameters for performance. For example, the pfSz is internally adjusted to a multiple of 4096 bytes. A code sample which uses startPagerObj() is in test3.cpp.
</p><p>Also note
  that totMem is an estimate of the total size which will be needed for the
  objects of this class. This is not a critical value, but if you provide a
  good guess, you will improve the performance by avoiding unnecessary
  reallocation of some internal arrays.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The
  page size must be at least 16 bytes. For text strings
  (see later), the page size must be at least the size of the longest string
  you will ever use. This is not an estimate; if you exceed this limit, you
  will get an error message about an unseccessful attempt to access a string
  which is too long.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>If
  you want all the objects of a certain class in memory, the X::startPager()
  call must use pageSize which includes the space of one or several objects to
  accomodate the Header. Two examples:</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>(A)
  500 objects of class X, sizeof(X)==12 will require 2 objects to accomodate
  the 16 byte Header. In order to keep all X instances in memory during the
  program run, use X::startPager(n,1,n,rd); where n&gt;=502*12.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>(B)
  400 objects of class X, sizeof(x)==28 will require 1 object to accomodate the
  Header. In order to keep all X instances in memory during the program run,
  use X::startPager(n,1,n,rd); where n&gt;=401*28.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>EXAMPLE
  OF THE MAIN PROGRAM</b></p>
  <pre><o:p>&nbsp;</o:p></pre><pre>#include &quot;factory.h&quot;</pre><pre>#include &quot;c.h&quot;</pre><pre>#include &quot;b.h&quot;</pre><pre>#include &quot;a.h&quot;</pre><pre><o:p>&nbsp;</o:p></pre><pre>int main() {</pre><pre><span style='mso-spacerun:yes'>    </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>A::startPager(1024,1000,100000000,0);</pre><pre><span style='mso-spacerun:yes'>    </span>B::startPager(40,2,1000,0);</pre><pre><span style='mso-spacerun:yes'>    </span>C::startPager(1000000,1,1000000,0);</pre><pre><span style='mso-spacerun:yes'>    </span>PersistStart;</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>... body of the main program ...</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>A::closePager();</pre><pre><span style='mso-spacerun:yes'>    </span>B::closePager();</pre><pre><span style='mso-spacerun:yes'>    </span>C::closePager();</pre><pre><span style='mso-spacerun:yes'>    </span>return 0;</pre><pre>}</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Note
  the selected configuration of disk paging:</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Class
  A will have up to 1000 pages in memory, each 1024 bytes in size. The total
  space estimated for objects of class A is 100MB, but this is not a hard
  limit. </p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Class
  B has only small pages (40 bytes), and at most 2 pages in memory at any given
  time. The total space occupied by objects of class B is estimated at 1kB.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Class
  C has large pages (100kB), only 1 page in memory, and the total size of the
  data 100kB. This means that if the estimate of the total size was correct,
  all C objects will be in memory all the time, without any paging. If the
  estimate proves to be low, this class will start swapping memory to disk.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The
  important thing about controlling the paging is that, except for class PersistString,
  the paging parameters can be different for different program runs. For
  example, if you have a computer with a lot of memory, this computer can use
  many large pages. Another computer can later use the same data with a reduced
  memory requirement. Both computers, of course, will depend on the same disk
  storage of the data.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The
  management of the strings is, internally, more complex, because it manages
  strings (and their free lists) for a wide variety of sizes. For this reason,
  the paging parameters must be identical for subsequent program runs. If they
  are not the same, PPF will print an error message. All strings automatically
  allocated within the boundary of a single page. The selected page size must
  be at least the size of the largest string you plan to use. This is a hard
  limit: If you ask for a larger string, PPF will refuse to allocate it, and
  will issue an error.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>You
  can close and restart the pager of any class several times (even using
  different paging parameters each time), but only one call to PersistStart is
  required after the initial opening of all pagers (calls to startPager) - see
  test1.cpp. </p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b
  style='mso-bidi-font-weight:normal'>IMPORTANT: Storing the data in a
  different directory<o:p></o:p></b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>By
  default, PPF stores the all the *.ppf files in the directory in which you are
  running your application. If you want to store the data in a different
  directory, call </p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-size:10.0pt;font-family:"Courier New"'><span
  style='mso-spacerun:yes'>    </span><b style='mso-bidi-font-weight:normal'>PersistFactory::setPath(char
  *path);<o:p></o:p></b></span></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-size:10.0pt;font-family:"Courier New"'>This is a smart function,
  you can call it with full or relative path using / or \, and if / or \
  is missing at the end, it supplies it automatically. All the following
  example work:<o:p></o:p></span></p>
  <p style='margin:0cm;margin-bottom:.0001pt;tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-size:10.0pt;font-family:"Courier New"'><span
  style='mso-spacerun:yes'>    </span>PersistFactory::setPath(c:\\mydata\\ppfTest);<o:p></o:p></span></p>
  <p style='margin:0cm;margin-bottom:.0001pt;tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-size:10.0pt;font-family:"Courier New"'><span
  style='mso-spacerun:yes'>    </span>PersistFactory::setPath(tmp/test321/);<o:p></o:p></span></p>
  <p style='margin:0cm;margin-bottom:.0001pt;tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-size:10.0pt;font-family:"Courier New"'><span
  style='mso-spacerun:yes'>    </span>PersistFactory::setPath();<o:p></o:p></span></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>CREATING
  AND DESTROYING OBJECTS</b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>If
  you want to make a class X persistent, register it by placing statement
  PersistClass(X); or PersistVclass(X); into its definition:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>class X {</pre><pre><span style='mso-spacerun:yes'>        </span>PersistVclass(X);</pre><pre><span style='mso-spacerun:yes'>        </span>int i;</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>public:</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Statement
  PersistVclass(X) is a macro which does not increase the size of the X
  objects; it only provides additional functions for this class. The most
  important functions are </p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>new(size_t sz)<span style='mso-spacerun:yes'>  </span>... is replaced, but it is used as usual</pre><pre><span style='mso-spacerun:yes'>    </span>newArr(long sz) ... creates a new array of this class,</pre><pre><span style='mso-spacerun:yes'>    </span>delObj()<span style='mso-spacerun:yes'>        </span>... destroys the object and place it on the free list,</pre><pre><span style='mso-spacerun:yes'>    </span>delArr()<span style='mso-spacerun:yes'>        </span>... destroys the array and place it on the free list.</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>As
  you see, you never really destroy objects, you only release them and place
  them on the free list. Operator delete() should NEVER be called.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Persistent
  objects must always be referenced through PersistVptr&lt;X&gt; or through
  PersistPtr&lt;X&gt;, never through normal pointer like X*. Such a pointer
  referes only to a temporary position in the memory pages, and is likely to
  change within your program run.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Automatically
  allocated objects are non-persistent, and ARE destroyed when they come out of
  scope. For example:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>int main(){</pre><pre><span style='mso-spacerun:yes'>        </span>PersistVptr&lt;X&gt; px,pa;</pre><pre><span style='mso-spacerun:yes'>        </span>X x;<span style='mso-spacerun:yes'>             </span>// non-persistent, automatic</pre><pre><span style='mso-spacerun:yes'>        </span>X *ppx;<span style='mso-spacerun:yes'>          </span>// should not appear in your program</pre><pre><span style='mso-spacerun:yes'>     </span></pre><pre><span style='mso-spacerun:yes'>        </span>px=new X;<span style='mso-spacerun:yes'>        </span>// one persistent object</pre><pre><span style='mso-spacerun:yes'>        </span>pa=X::newArr(7); // array of 7 persistent objects</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>        </span>// destroying the objects</pre><pre><span style='mso-spacerun:yes'>        </span>px-&gt;delObj();<span style='mso-spacerun:yes'>    </span>// equivalent of: delete px;</pre><pre><span style='mso-spacerun:yes'>        </span>pa-&gt;delArr();<span style='mso-spacerun:yes'>    </span>// equivalent of: delete[] pa;</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>        </span>// never do this</pre><pre><span style='mso-spacerun:yes'>        </span>ppx=new X;<span style='mso-spacerun:yes'>       </span>// WRONG: pointer in a temporary page</pre><pre><span style='mso-spacerun:yes'>        </span>delete pa;<span style='mso-spacerun:yes'>       </span>// WRONG syntax: pa is an object and not pointer</pre><pre><span style='mso-spacerun:yes'>        </span>delete &amp;pa;<span style='mso-spacerun:yes'>      </span>// destroys pa but not the persistent object</pre><pre><span style='mso-spacerun:yes'>    </span>} // here x is destroyed automatically</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The
  allocation of strings is similar</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>        </span>PersistString name;<span style='mso-spacerun:yes'>            </span>// pointer to a persistent string</pre><pre><span style='mso-spacerun:yes'>        </span>char *p; static char *s[]={&quot;rb&quot;,&quot;wb&quot;}; // non-persistent strings</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>        </span>p=new char[8];<span style='mso-spacerun:yes'>                   </span>// non-persistent string 8 bytes long</pre><pre><span style='mso-spacerun:yes'>        </span>name=new PersistString(8);<span style='mso-spacerun:yes'>       </span>// persistent string 8 bytes long</pre><pre><span style='mso-spacerun:yes'>        </span>name=new PersistString(&quot;first&quot;); // make the text persistent</pre><pre><span style='mso-spacerun:yes'>        </span>name=new PersistString(s[0]);<span style='mso-spacerun:yes'>    </span>// another example</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>      </span>delete[] p;<span style='mso-spacerun:yes'>        </span>// destroying non-persistent object</pre><pre><span style='mso-spacerun:yes'>        </span>name-&gt;delString(); // moves string to free list, retains the pointer</pre><pre><span style='mso-spacerun:yes'>        </span>delete name;<span style='mso-spacerun:yes'>       </span>// destroys the pointer, moves string to free list</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>Notes:</b>
  An array of T objects must be allocated with PersistPtr<T>::newArr(int size),
  not with T::new[](). We were not able to overload this operator successfully
  due to its unpredictable behaviour in VC++.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Also,
  neither delete() nor delete[]() can be easily overloaded in our case:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>class A { ... };</pre><pre><span style='mso-spacerun:yes'>    </span>PersistPtr&lt;A&gt; p;</pre><pre><span style='mso-spacerun:yes'>    </span>p = new A; // this works</pre><pre><span style='mso-spacerun:yes'>    </span>delete p; // compiler error</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The
  compiler does not know how to interpret the last line. If we write </p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>         </span>delete &amp;(*p);</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>the
  compiler understands that we are dealing with class A, but we lose access to
  the disk address which is critical here.Another possibility is to write</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>         </span>delete A::(&amp;p);</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>which
  is forced to enter A::delete(), and passes to it p which stores the disk
  address. This syntax is however error prone and ugly. My preference still is
  to use a separate function:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>p = new A;</pre><pre><span style='mso-spacerun:yes'>    </span>p.delObj();</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Also
  note that even though we use PersistPtr as a pointer, it is really and
  object, which reflects in how we can use it in if() statements: </p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>class A { ... };</pre><pre><span style='mso-spacerun:yes'>    </span>PersistPtr&lt;A&gt; p;</pre><pre><span style='mso-spacerun:yes'>    </span>if(p==NULL)...<span style='mso-spacerun:yes'>  </span>// works as expected</pre><pre><span style='mso-spacerun:yes'>    </span>if(p!=NULL)...<span style='mso-spacerun:yes'>  </span>// works as expected</pre><pre><span style='mso-spacerun:yes'>    </span>if(p)<span style='mso-spacerun:yes'>  </span>...<span style='mso-spacerun:yes'>      </span>// does not work</pre><pre><span style='mso-spacerun:yes'>    </span>if(!p) ...<span style='mso-spacerun:yes'>      </span>// does not work</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>DEFAULT
  CONSTRUCTORS</b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>PPF
  has to update special fields (virtual function pointers) which are implanted
  into objects by the C++ compiler. Many programmers are not even aware that
  these pointers are hidden in their objects.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Default
  constructors of certain classes are essential for the management of these
  pointers, and this leads to the following <b>rules</b>:</p>
  <ol start=1 type=1>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l1 level1 lfo3;tab-stops:list 36.0pt'><b>In PPF Ver.1.4
       and less:</b> PersistVptr classes and classes that form members in other
       classes must have empty default constructors. This implies the necessity
       to have additional functions (called <i>init()</i> below) for
       initialization.</li>
   <li class=MsoNormal style='mso-margin-top-alt:auto;mso-margin-bottom-alt:
       auto;mso-list:l1 level1 lfo3;tab-stops:list 36.0pt'><b>In PPF Ver.2.0
       and higher:</b> PersistVptr classes and classes that form members in
       other classes must either have empty default constructors, of these
       constructors must start with the <i>PersistConstructor;</i> statement. </li>
  </ol>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>// ----------------------</pre><pre><span style='mso-spacerun:yes'>    </span>// PPF Ver.1.4 and before</pre><pre><span style='mso-spacerun:yes'>    </span>// ----------------------</pre><pre><span style='mso-spacerun:yes'>    </span>class Y {</pre><pre><span style='mso-spacerun:yes'>        </span>PersistClass(Y);</pre><pre><span style='mso-spacerun:yes'>        </span>int k;</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>public:</pre><pre><span style='mso-spacerun:yes'>        </span>Y(){}<span style='mso-spacerun:yes'>   </span>// must be empty because Y forms a member X::y</pre><pre><span style='mso-spacerun:yes'>        </span>void init(){k=0;}</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>class X {</pre><pre><span style='mso-spacerun:yes'>        </span>PersistVclass(X);</pre><pre><span style='mso-spacerun:yes'>        </span>int i;</pre><pre><span style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>      </span>Y y;<span style='mso-spacerun:yes'>  </span></pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>public:</pre><pre><span style='mso-spacerun:yes'>        </span>X(){}<span style='mso-spacerun:yes'>  </span>// must be empty because X is PersistVclass</pre><pre><span style='mso-spacerun:yes'>        </span>void init(){i=0; y.init();} // normally would be in the default constructor</pre><pre><span style='mso-spacerun:yes'>        </span>X(int k){i=k;}<span style='mso-spacerun:yes'>              </span>// other constructors coded as usual</pre><pre><span style='mso-spacerun:yes'>   </span><span style='mso-spacerun:yes'>     </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>PersistVptr px=new X;</pre><pre><span style='mso-spacerun:yes'>    </span>px-&gt;init(); </pre><pre><span style='mso-spacerun:yes'>    </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>px=new X(7); // the other constructor</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>// ---------------------</pre><pre><span style='mso-spacerun:yes'>    </span>// PPF Ver.2.0 and later</pre><pre><span style='mso-spacerun:yes'>    </span>// ---------------------</pre><pre><span style='mso-spacerun:yes'>    </span>class Y {</pre><pre><span style='mso-spacerun:yes'>        </span>PersistClass(Y);</pre><pre><span style='mso-spacerun:yes'>        </span>int k;</pre><pre><span style='mso-spacerun:yes'>    </span><span style='mso-spacerun:yes'>    </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>public:</pre><pre><span style='mso-spacerun:yes'>        </span>Y(){PersistConstructor; k=0;}<span style='mso-spacerun:yes'>  </span>// default constructor</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>class X {</pre><pre><span style='mso-spacerun:yes'>        </span>PersistVclass(X);</pre><pre><span style='mso-spacerun:yes'>        </span>int i;</pre><pre><span style='mso-spacerun:yes'>        </span>Y y;<span style='mso-spacerun:yes'>  </span></pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>public:</pre><pre><span style='mso-spacerun:yes'>        </span>X(){PersistConstructor; i=0;}<span style='mso-spacerun:yes'>  </span>// Y() called for y as default</pre><pre><span style='mso-spacerun:yes'>        </span>X(int k){i=k;} // other constructors coded as usual</pre><pre><span style='mso-spacerun:yes'>        </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>};</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>    </span>PersistVptr px=new X; // no call to init()</pre><pre><span style='mso-spacerun:yes'>    </span>...</pre><pre><span style='mso-spacerun:yes'>    </span>px=new X(7);<span style='mso-spacerun:yes'>          </span>// as before</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>If
  you don't use any <i>PersistVclass</i> classes (all your persistent classes are
  only <i>PersistClass</i>), and no class uses members which are instances of
  another class or, in other words, you only have lightweight classes, then you
  don't have to worry about these rules. <b>However, if </b><i>PersistConstructor</i><b>
  must be used even for a single class, it is recommended that you apply it
  indiscriminantly to all your classes.</b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The
  reason is that <b>if you forget about this rule for some class, PPF will
  malfunction in a hideous way, which is difficult to diagnose and debug. </b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>There
  is no special rule for destructors, they can be used as usual.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>HOW
  THE DATA IS STORED</b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Objects
  of each class are stored in one file, using the class name as the file name.
  For example, class MyBook will be stored in file mybook.ppf. Under Windows or
  DOS, select class names not longer than 8 characters. Longer names may work,
  but not always. There is no problem with the size of the class names under
  UNIX.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Storing
  objects of each class in its own file improves the organization and
  performance. If objects of a certain class are not used in your run, the file
  for that class will not be even opened. Also, if many objects of some class
  are frequently needed, you can give this class more paging space, and thus to
  improve the overall performance.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>In
  addition to one *.ppf file for each class, there is also file classes.ppf. In
  this file, PPF keeps the list of classes used by your program. This list is
  ordered in certain way, and is critical for the correct operation of PPF.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The
  necessity of dealing with dozens and perhaps hundreds of files may look like
  a nuisance, but you can easily combine these files by using pkzip or tar for
  all *.ppf files, and unpack them later.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Note:
  When you allocate PersistPtr&lt;T&gt; or PersistString by itself (does not
  matter whether automatically or from the heap), it does not trigger any disk
  storage. But when you assign them to a T object or to a string, the object
  and the string become persistent. For example:</p>
  <p style='margin:0cm;margin-bottom:.0001pt;tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-family:"Courier New"'>class A;<o:p></o:p></span></p>
  <p style='margin:0cm;margin-bottom:.0001pt;tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-family:"Courier New"'>void foo(){ PersistPtr&lt;A&gt; p; } //
  triggers no disk storage yet<o:p></o:p></span></p>
  <p style='margin:0cm;margin-bottom:.0001pt;tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-family:"Courier New"'>void foo(){ PersistPtr&lt;A&gt; p; p=new
  A;} // stores A on disk<o:p></o:p></span></p>
  <p style='margin:0cm;margin-bottom:.0001pt;tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-family:"Courier New"'>void foo(){ PersistString s; } // triggers
  no disk storage yet<o:p></o:p></span></p>
  <p style='margin:0cm;margin-bottom:.0001pt;tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-family:"Courier New"'>void foo(){ PersistString
  s(&quot;abcd&quot;); } // stores string &quot;abcd&quot; on disk<o:p></o:p></span></p>
  <p style='margin:0cm;margin-bottom:.0001pt;tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-family:"Courier New"'>void foo(){ PersistString s;
  s=&quot;abcd&quot;; } // stores string &quot;abcd&quot; on disk<o:p></o:p></span></p>
  <p style='font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>
	  TRANSACTIONAL and ALL-DATA-IN-MEMORY modes</b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The basic mode in which PPF runs is transactional. Only the pages with the data you
 actually access are loaded to memory.</p>
 <p> In programs that access and traverse all the data, 
 the most efficient mode of operation is to bring
 all the data into virtual memory, and then access it as memory-resident data.
 This happens automatically, and you do not have to do anything special to run
 in this mode except for selecting large enough maxPgs
 in all the startPager() calls.</p>
 <p> This works fine, but data saving and opening is slower than for well designed 
 serialization. The reason is that serialization accesses the disk data 
 sequantially, while PPF uses random disk IO. There are two little trick though
 that make PPF much faster that any serialization.
 </p>
 <p> Trick No.1 is, at the beginning of the PPF run, we read sequentially the 
 disk files in which PPF stores the data (*.ppf files), while throwing away
 what we just read. This moves the disk data into the HD cache which, on
 today's hardware, is usually 2GB. Any subsequent disk read is reduced to 
 an access call to this cache. In order to invoke this mode, call in the
 beginning of the PPF run</p>
  <p style='margin:0cm;margin-bottom:.0001pt;tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-family:"Courier New"'>PersistFactory::warmDiskCache();<o:p></o:p></span></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>
  Trick No.2 is to access, in the order in which the pages are stored on
  the disk, one object in each page, typically the first object. This triggers
  serial traversal of the disk, while loading the data directly  in the appropriate pages.
  This is only slightly faster than Trick No.1, according to our experience only
  about 8%.
  In order to invoke this mode, call in the beginning of the PPF run
 </p>
  <p style='margin:0cm;margin-bottom:.0001pt;tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-family:"Courier New"'>PersistFactory::preloadPages();<o:p></o:p></span></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><span
  style='font-family:"Courier New"'><o:p>&nbsp;</o:p></span></p>

  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>
	  EFFICIENT IMPLEMENTATION -- (32/64-bit compilers)</b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>This
  entire system is elegant and efficient. Compare this with OODB systems or
  persistent mechanisms provided by other vendors. When you use PPF, you need
  only:</p>
  <pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>   </span>factory.h<span style='mso-spacerun:yes'>   </span>... some 300 lines of code (without space lines and comments)</pre><pre><span style='mso-spacerun:yes'>   </span>pointer.cpp ... some 50 lines of code (without space lines and comments)</pre><pre><span style='mso-spacerun:yes'>   </span>factory.obj ... about 30kB</pre>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The
  program is written with C++ templates, and is platform independent. It should
  run under any operating system and/or compiler, 32 or 64 bits.</p>
  The basic software as you download it is optimized for data smaller then 2^31,
  which is 2,147,483,648. For larger data, you must compile under 64 bits, and 
  also uncomment the following line in the beginning of file factory.h:
  #define LARGE_DATA_SET</p>
  Note how efficient PPF is. If you run with normal data,
  the persistent pointers are only 4 bytes in 64-bit environments, 
  which makes your objects are smaller
  than it may seem physically possible. For example the equivalent of
  <pre>
  class Book {
  PersistClass(Book);
      Book *next;
      Author *author;
      char *title;
      float price;
  };
  </pre>
  whether you run under 32 bits or 64 bits results in sizeof(Book) returning
  16 and not (3*8 +4)=28 rounded to multiple of 8 as 32 that you normally get
  in 64-bit environments.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>The
  following numbers demonstrate the efficiency of the disk storage: When
  running program test1 (regr.bat) under Win95, sizeof(A)=4, sizeof(B)=12, you
  store 46,530 objects of class A, each 4B, total size of 186,120 bytes. If you
  allocate A objects as an array, this would be total of 186,120 bytes. If you
  allocate them individually, the allocator uses internally 4 bytes for each
  object, and the total memory used is 372,240. The size of the disk file to
  which the data is paged is 186,288 bytes. This represents only 1/100 of
  percent overhead over a non-persistent array representation, or about 1/2 of
  the memory needed for non-persistent, individually allocated objects.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'><b>TEST
  EXAMPLES</b></p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Look
  at the script file regr.bat or regr; they run a regression test of several programs.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Test1
  represents a complete, running example with 2 light-weight classes. The
  example includes a linked list of arrays, plus a simple class-to-class
  pointer link.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>test1.cpp
  is the main program, and includes the description of the problem.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>test1a.h,
  test1a.cpp implement class A,</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>test1b.h,
  test1b.cpp implement class B.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>If
  you check the sizes of files a.ppf and b.ppf, you will see that there is
  practically no overhead when storing the data on disk.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>In
  Test2, we have a linked list of B objects, where each B object keeps a single
  A object, plus an array of A objects - each array has a different size. Test2
  is similar to test1, except that we have classes A,B,C,and D, where C and D
  are derived (inherit) from B. We still have a linked list of B objects, but
  these objects truly are C,D,C,D,...,C,D. The attached A objects and arrays of
  A's are the same as in test1.</p>
  <p style='tab-stops:45.8pt 91.6pt 137.4pt 183.2pt 229.0pt 274.8pt 320.6pt 366.4pt 412.2pt 458.0pt 503.8pt 549.6pt 595.4pt 641.2pt 687.0pt 732.8pt'>Test3
  has a linked list of a light-weight class A, with two strings (name and
  address) attached to each A object. All three programs (test1, test2, test3)
  generate the data internally, and then check the results automatically. When
  everything is all right, they print message &quot;No errors&quot;.</p>
  <pre><o:p>&nbsp;</o:p></pre><pre>test1 1<span style='mso-spacerun:yes'>   </span>generates data for test1, checks it, and leaves it on disk.</pre><pre>test1 2<span style='mso-spacerun:yes'>   </span>opens the disk files and checks the data in read-only mode</pre><pre>test1 3<span style='mso-spacerun:yes'>   </span>opens the disk files and checks the data in read/write mode</pre><pre>test2 1<span style='mso-spacerun:yes'>   </span>generates data for test2, checks it, and leaves it on disk.</pre><pre>test2 2<span style='mso-spacerun:yes'>   </span>opens the disk files and checks the data.</pre><pre>test3 1<span style='mso-spacerun:yes'>   </span>generates data for test3, checks it, and leaves it on disk.</pre><pre>test3 2<span style='mso-spacerun:yes'>   </span>opens the disk files, releases 1/8 of the strings, and</pre><pre><span style='mso-spacerun:yes'>          </span>they are all removed, replaces them by a different string</pre><pre><span style='mso-spacerun:yes'>          </span>of the same length. It leaves results on disk - both files</pre><pre><span style='mso-spacerun:yes'>          </span>a.ppf and string.ppf should have the same size as originally.</pre><pre>test3 3<span style='mso-spacerun:yes'>   </span>opens in the read-only mode and checks that the new data is in place.</pre><pre><o:p>&nbsp;</o:p></pre><pre><span style='mso-spacerun:yes'>                                             </span>Jiri Soukup, Dec.19/99</pre><pre><span style='mso-spacerun:yes'>                                             </span>update for Ver.2.2 Jan.29/03</pre></td>
 </tr>
</table>

</div>

<p class=MsoNormal align=center style='text-align:center'><span lang=EN-US
style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

</div>

</body>

</html>
